# main.py
from fastapi import FastAPI, HTTPException, Header, BackgroundTasks
from typing import List, Optional
from pydantic import BaseModel, HttpUrl
from prompt import founder_template, founder_dynamics_template, talking_points_marketopp_template, talking_points_coach_template, concerns_template
from langchain.chains import LLMChain
from fastapi.middleware.cors import CORSMiddleware
from celery import Celery
from celery.result import AsyncResult

import os
import requests
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI

from scoring import scoring_prompt

load_dotenv()

# FastAPI app
app = FastAPI()

# Celery configuration
celery_app = Celery('tasks', broker='redis://redis:6379/0', backend='redis://redis:6379/0')
celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# OpenAI configuration
os.environ['OPENAI_API_KEY'] = os.environ.get('OPENAI_API_KEY')
llm = ChatOpenAI(model="gpt-4-0613")

# API Key (replace with a more secure method in production)
API_KEY = os.environ.get('API_KEY', 'your-api-key')

# Pydantic models
class CompanyInfo(BaseModel):
    # ... (keep all the fields from the original CompanyInfo model)

# Global company data store (replace with a database in production)
company = {}

# Helper function to validate API key
def validate_api_key(api_key: str = Header(...)):
    if api_key != API_KEY:
        raise HTTPException(status_code=403, detail="Invalid API key")
    return api_key

@app.get("/")
def read_root():
    return {"message": "Hello, FastAPI with Celery! Go to /docs for API documentation."}

@app.post("/submit-company-info/")
async def submit_company_info(info: CompanyInfo, company_id: int, api_key: str = Header(...)):
    validate_api_key(api_key)
    if company_id in company:
        return {"message": "Company info already submitted"}
    company[company_id] = info
    return {"message": "Company info submitted successfully", "data": info}

@celery_app.task(name="process_company_data")
def process_company_data(company_id: int, row_id: str, submission_id: str):
    if company_id not in company:
        return {"error": "Company not found"}

    company_data = company[company_id]
    input_json = {
        # ... (convert company_data to input_json as in the original code)
    }

    # Process data using LLMChain (as in the original code)
    llm_chain = LLMChain(prompt=founder_template, llm=llm)
    response = llm_chain.invoke(input_json)

    founder_dynamics_chain = LLMChain(prompt=founder_dynamics_template, llm=llm)
    response2 = founder_dynamics_chain.invoke(input_json)

    talking_points_marketopp_chain = LLMChain(prompt=talking_points_marketopp_template, llm=llm)
    response3 = talking_points_marketopp_chain.invoke(input_json)

    talking_points_coach_chain = LLMChain(prompt=talking_points_coach_template, llm=llm)
    response4 = talking_points_coach_chain.invoke(input_json)

    concerns_chain = LLMChain(prompt=concerns_template, llm=llm)
    response5 = concerns_chain.invoke(input_json)

    scoring_chain = LLMChain(prompt=scoring_prompt, llm=llm)
    response6 = scoring_chain.invoke(input_json)

    result = {
        "founder_summary": response['text'],
        "founder_dynamics": response2['text'],
        "talking_points_marketopp": response3['text'],
        "talking_points_coach": response4['text'],
        "concerns": response5['text'],
        "scoring": response6['text']
    }

    # Send webhook notification
    webhook_url = os.environ.get('WEBHOOK_URL', 'https://example.com/webhook')
    requests.post(webhook_url, json={
        "row_id": row_id,
        "submission_id": submission_id,
        "status": "completed",
        "result": result
    })

    return result

@app.post("/process-company/{company_id}")
async def process_company(
    company_id: int,
    row_id: str,
    submission_id: str,
    background_tasks: BackgroundTasks,
    api_key: str = Header(...)
):
    validate_api_key(api_key)
    if company_id not in company:
        raise HTTPException(status_code=404, detail="Company not found")

    task = process_company_data.delay(company_id, row_id, submission_id)
    return {"message": "Processing started", "task_id": task.id}

@app.get("/task-status/{task_id}")
async def get_task_status(task_id: str, api_key: str = Header(...)):
    validate_api_key(api_key)
    task_result = AsyncResult(task_id)
    return {
        "task_id": task_id,
        "status": task_result.status,
        "result": task_result.result if task_result.ready() else None
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get('PORT', 8080)))

# In a separate file named 'celery_worker.py':
from celery import Celery

app = Celery('tasks', broker='redis://redis:6379/0', backend='redis://redis:6379/0')

# Include the tasks from main.py
app.autodiscover_tasks(['main'])

# To run the Celery worker:
# celery -A celery_worker worker --loglevel=info

# To run Flower for monitoring:
# celery -A celery_worker flower